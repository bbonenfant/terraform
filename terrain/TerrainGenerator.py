import pymesh
import subprocess
import numpy as np
from os import path
from shapely.geometry import Point, Polygon
from xml.etree import ElementTree


class TerrainGenerator:
    """ Class for generating terrain from a ipe file with the outline of a river. """

    _data_directory = path.join(path.dirname(__file__), 'data')
    _terrain_file = path.join(_data_directory, 'terrain.off')
    _subset_file = path.join(_data_directory, 'terrain_subset.off')

    def __init__(self, ipe_file, stalgo_executable, terrain_maximum_height=0.015, terrain_slope=0.200):
        """
        :param ipe_file: Path to the ipe file with the outline of a river.
        :param stalgo_executable: Path to the STALGO executable.
        :param terrain_maximum_height: Maximum terrain height generated by STALGO.
        :param terrain_slope: Slope used by STALGO.
        """
        self.file = ipe_file
        self.stalgo = stalgo_executable
        self.max_height = terrain_maximum_height
        self.slope = terrain_slope

    def run(self):
        """ Generate the terrain file. """
        self.execute_stalgo(self.stalgo, self.file, self.max_height, self.slope)
        self._subset_mesh()

    @staticmethod
    def execute_stalgo(stalgo_executable, ipe_file, terrain_maximum_height, terrain_slope, out_file=_terrain_file):
        """
            Run STALGO.
        :param stalgo_executable: Path to the STALGO executable.
        :param ipe_file: Path to the ipe file with the outline of a river.
        :param terrain_maximum_height: Maximum terrain height generated by STALGO.
        :param terrain_slope: Slope used by STALGO.
        :param out_file: Path to the output file.
        """
        subprocess.run((f'{stalgo_executable} --sk --input {ipe_file} --output-terrain {out_file} '
                        f'--output-terrain-maxheight {terrain_maximum_height} '
                        f'--output-terrain-slope {terrain_slope}').split())

    def _subset_mesh(self):
        """ Subset the STALGO output mesh by removing the river and points outside of the offset. """
        # Get the total mesh and the river polygon.
        mesh = pymesh.load_mesh(self._terrain_file)
        river = self.get_river_polygon()

        # Collect all the vertices whose projection onto the XY plane are *strictly* within the river polygon.
        #   The buffer of 0.001 gives the vertices some thickness which is needed due to floating point error
        #     i.e. collect all vertices such that a ball of radius 0.001 centered at the vertex is entirely contained
        #     within the polygon.
        vertices_to_be_removed = [index for index, vertex in enumerate(mesh.vertices)
                                  if Point(vertex[:2]).buffer(0.001).within(river)]

        # Do some numpy indexing magic to convert vertices_to_be_removed to faces_to_keep.
        vertices_to_keep = np.ones(mesh.num_vertices, dtype=bool)
        vertices_to_keep[vertices_to_be_removed] = False
        faces_to_keep = np.all(vertices_to_keep[mesh.faces], axis=1)
        selected_faces = np.arange(mesh.num_faces, dtype=int)[faces_to_keep]

        # Subset the original mesh, only keeping the selected faces.
        subset_mesh = pymesh.submesh(mesh, selected_faces, 0)

        # Save to file.
        pymesh.save_mesh(filename=self._subset_file, mesh=subset_mesh)

    def get_river_polygon(self):
        """ Construct a Polygon from the vertices of the river that are extracted from the ipe file. """
        # Extract the river layer from the ipe file.
        river = self._extract_layer('polychains').find('path')

        # Scape the xml text for the points and construct a (nx2) numpy array.
        point_list = river.text.replace('m', '').replace('l', '').split()
        vertices = np.array([[float(start), float(end)] for start, end in zip(*[iter(point_list)] * 2)])

        # Translate and scale the coordinates to their original state.
        vertices = self.rescale_from_ipe(vertices)

        return Polygon(vertices)

    def _extract_layer(self, layer_name):
        """
            Extract the layer corresponding with layer_name from ipe_file.
        :param layer_name: The name of the layer to be extracted.
        :return: Xml Element instance.
        """
        tree = ElementTree.parse(self.file)
        page = tree.getroot().find('page')
        return next(group for group in page.findall('group') if group.attrib['layer'] == layer_name)

    @staticmethod
    def rescale_from_ipe(points, translation_vector=(300, 450), scale_factor=200):
        """
            Rescale and translate points from the ipe file.
            STALGO translates and scales the points by (300, 450) and 200 respectively so that
              the image can be seen in the IPE app. We need undo this to line up with the terrain mesh.
        :param points: Array of points from an ipe file.
        :param translation_vector: The vector that was used to spatially translate the ipe points.
        :param scale_factor: The fact that was used to scale up the ipe points.
        :return: Scaled and translated ndarray of points.
        """
        return (np.asarray(points) - np.asarray(translation_vector)) / scale_factor
